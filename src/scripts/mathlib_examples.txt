Nat.div_eq_sub_mod_div :

‚àÄ {m n : ‚Ñï}, m / n = (m - m % n) / n

=======================

Real.contDiffAt_rpow_of_ne :

‚àÄ (p : ‚Ñù √ó ‚Ñù), p.1 ‚â† 0 ‚Üí ‚àÄ {n : WithTop ‚Ñï‚àû}, ContDiffAt ‚Ñù n (fun p ‚Ü¶ p.1 ^ p.2) p

=======================

Set.Sum.elim_range :

‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {Œ≥ : Type u_3} (f : Œ± ‚Üí Œ≥) (g : Œ≤ ‚Üí Œ≥),
  Set.range (Sum.elim f g) = Set.range f ‚à™ Set.range g

=======================

Finset.vaddAssocClass :

‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_3} {Œ≥ : Type u_4} [inst : DecidableEq Œ≥] [inst_1 : VAdd Œ± Œ≤] [inst_2 : VAdd Œ± Œ≥]
  [inst_3 : VAdd Œ≤ Œ≥] [VAddAssocClass Œ± Œ≤ Œ≥], VAddAssocClass Œ± Œ≤ (Finset Œ≥)

=======================

Nat.succ_mul_centralBinom_succ :

‚àÄ (n : ‚Ñï), (n + 1) * (n + 1).centralBinom = 2 * (2 * n + 1) * n.centralBinom

=======================

Set.image_single_Ioo_left :

‚àÄ {Œπ : Type u_1} {Œ± : Œπ ‚Üí Type u_2} [inst : DecidableEq Œπ] [inst_1 : (i : Œπ) ‚Üí PartialOrder (Œ± i)]
  [inst_2 : (i : Œπ) ‚Üí Zero (Œ± i)] (i : Œπ) (a : Œ± i), Pi.single i '' Set.Ioo a 0 = Set.Ioo (Pi.single i a) 0

=======================

Finset.Nonempty.of_compls :

‚àÄ {Œ± : Type u_2} [inst : BooleanAlgebra Œ±] {s : Finset Œ±}, s.compls.Nonempty ‚Üí s.Nonempty

=======================

Nat.div_dvd_iff_dvd_mul :

‚àÄ {a b c : ‚Ñï}, b ‚à£ a ‚Üí 0 < b ‚Üí (a / b ‚à£ c ‚Üî a ‚à£ b * c)

=======================

Real.circleAverage_add :

‚àÄ {E : Type u_1} [inst : NormedAddCommGroup E] [inst_1 : NormedSpace ‚Ñù E] {f‚ÇÅ f‚ÇÇ : ‚ÑÇ ‚Üí E} {c : ‚ÑÇ} {R : ‚Ñù},
  CircleIntegrable f‚ÇÅ c R ‚Üí
    CircleIntegrable f‚ÇÇ c R ‚Üí Real.circleAverage (f‚ÇÅ + f‚ÇÇ) c R = Real.circleAverage f‚ÇÅ c R + Real.circleAverage f‚ÇÇ c R

=======================

Set.Nonempty.of_infs_left :

‚àÄ {Œ± : Type u_2} [inst : SemilatticeInf Œ±] {s t : Set Œ±}, (s ‚äº t).Nonempty ‚Üí s.Nonempty

=======================

Finset.cast_divConst :

‚àÄ {G : Type u_1} [inst : Group G] [inst_1 : DecidableEq G] {ùïú : Type u_3} [inst_2 : Semifield ùïú] [CharZero ùïú]
  (A B : Finset G), ‚Üë(A.divConst B) = ‚Üë(A / B).card / ‚ÜëA.card

=======================

Int.fract_natCast_add :

‚àÄ {R : Type u_2} [inst : Ring R] [inst_1 : LinearOrder R] [inst_2 : FloorRing R] [IsStrictOrderedRing R] (n : ‚Ñï)
  (a : R), Int.fract (‚Üën + a) = Int.fract a

=======================

Set.indicator_nonpos_le_indicator :

‚àÄ {Œ± : Type u_2} {M : Type u_3} [inst : Zero M] [inst_1 : LinearOrder M] (s : Set Œ±) (f : Œ± ‚Üí M),
  {a | f a ‚â§ 0}.indicator f ‚â§ s.indicator f

=======================

Finset.mem_image‚ÇÇ_of_mem :

‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_3} {Œ≥ : Type u_5} [inst : DecidableEq Œ≥] {f : Œ± ‚Üí Œ≤ ‚Üí Œ≥} {s : Finset Œ±} {t : Finset Œ≤}
  {a : Œ±} {b : Œ≤}, a ‚àà s ‚Üí b ‚àà t ‚Üí f a b ‚àà Finset.image‚ÇÇ f s t

=======================

Nat.mem_divisors_self :

‚àÄ (n : ‚Ñï), n ‚â† 0 ‚Üí n ‚àà n.divisors

=======================

Finset.addZeroClass.eq_1 :

‚àÄ {Œ± : Type u_2} [inst : DecidableEq Œ±] [inst_1 : AddZeroClass Œ±],
  Finset.addZeroClass = Function.Injective.addZeroClass Finset.toSet ‚ãØ ‚ãØ ‚ãØ

=======================

Real.cos_pi_div_two_sub :

‚àÄ (x : ‚Ñù), Real.cos (Real.pi / 2 - x) = Real.sin x

=======================

Int.sub_left_le_of_le_add :

‚àÄ {a b c : ‚Ñ§}, a ‚â§ b + c ‚Üí a - b ‚â§ c

=======================

Finset.addAction.eq_1 :

‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_3} [inst : DecidableEq Œ≤] [inst_1 : DecidableEq Œ±] [inst_2 : AddMonoid Œ±]
  [inst_3 : AddAction Œ± Œ≤], Finset.addAction = { toVAdd := Finset.vadd, zero_vadd := ‚ãØ, add_vadd := ‚ãØ }

=======================

Set.preimage_neg_Iic :

‚àÄ {Œ± : Type u_1} [inst : AddCommGroup Œ±] [inst_1 : PartialOrder Œ±] [IsOrderedAddMonoid Œ±] (a : Œ±),
  -Set.Iic a = Set.Ici (-a)

=======================

Nat.Prime.divisors :

‚àÄ {p : ‚Ñï}, Nat.Prime p ‚Üí p.divisors = {1, p}

=======================

Nat.psub_eq_none :

‚àÄ {m n : ‚Ñï}, m.psub n = none ‚Üî m < n

=======================

Set.Iic_prod_Iic :

‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : Preorder Œ±] [inst_1 : Preorder Œ≤] (a : Œ±) (b : Œ≤),
  Set.Iic a √óÀ¢ Set.Iic b = Set.Iic (a, b)

=======================

Int.OfNat.Expr.mul.inj :

‚àÄ {a b a_1 b_1 : Int.OfNat.Expr}, a.mul b = a_1.mul b_1 ‚Üí a = a_1 ‚àß b = b_1

=======================

Int.fmod_eq_of_lt :

‚àÄ {a b : ‚Ñ§}, 0 ‚â§ a ‚Üí a < b ‚Üí a.fmod b = a

=======================

Nat.zeckendorf_succ :

‚àÄ (n : ‚Ñï), (n + 1).zeckendorf = (n + 1).greatestFib :: (n + 1 - Nat.fib (n + 1).greatestFib).zeckendorf

=======================

Nat.count_iff_forall :

‚àÄ {p : ‚Ñï ‚Üí Prop} [inst : DecidablePred p] {n : ‚Ñï}, Nat.count p n = n ‚Üî ‚àÄ n' < n, p n'

=======================

Finset.erase_ssubset :

‚àÄ {Œ± : Type u_1} [inst : DecidableEq Œ±] {a : Œ±} {s : Finset Œ±}, a ‚àà s ‚Üí s.erase a ‚äÇ s

=======================

Set.subsingleton_coe_of_subsingleton :

‚àÄ {Œ± : Type u} [Subsingleton Œ±] {s : Set Œ±}, Subsingleton ‚Üës

=======================

Int.addLeft_one_isCycle :

(Equiv.addLeft 1).IsCycle

=======================

Finset.image‚ÇÇ_left :

‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_3} {s : Finset Œ±} {t : Finset Œ≤} [inst : DecidableEq Œ±],
  t.Nonempty ‚Üí Finset.image‚ÇÇ (fun x x_1 ‚Ü¶ x) s t = s

=======================

Nat.odd_fermatNumber :

‚àÄ (n : ‚Ñï), Odd n.fermatNumber

=======================

Finset.expect_bij' :

‚àÄ {Œπ : Type u_1} {Œ∫ : Type u_2} {M : Type u_3} [inst : AddCommMonoid M] [inst_1 : _root_.Module ‚Ñö‚â•0 M] {s : Finset Œπ}
  {f : Œπ ‚Üí M} {t : Finset Œ∫} {g : Œ∫ ‚Üí M} (i : (a : Œπ) ‚Üí a ‚àà s ‚Üí Œ∫) (j : (a : Œ∫) ‚Üí a ‚àà t ‚Üí Œπ)
  (hi : ‚àÄ (a : Œπ) (ha : a ‚àà s), i a ha ‚àà t) (hj : ‚àÄ (a : Œ∫) (ha : a ‚àà t), j a ha ‚àà s),
  (‚àÄ (a : Œπ) (ha : a ‚àà s), j (i a ha) ‚ãØ = a) ‚Üí
    (‚àÄ (a : Œ∫) (ha : a ‚àà t), i (j a ha) ‚ãØ = a) ‚Üí
      (‚àÄ (a : Œπ) (ha : a ‚àà s), f a = g (i a ha)) ‚Üí (s.expect fun i ‚Ü¶ f i) = t.expect fun i ‚Ü¶ g i

=======================

Real.logb_nonneg_iff :

‚àÄ {b x : ‚Ñù}, 1 < b ‚Üí 0 < x ‚Üí (0 ‚â§ Real.logb b x ‚Üî 1 ‚â§ x)

=======================

Set.IsPWO.addSubmonoid_closure :

‚àÄ {Œ± : Type u_1} [inst : AddCommMonoid Œ±] [inst_1 : PartialOrder Œ±] [IsOrderedCancelAddMonoid Œ±] {s : Set Œ±},
  (‚àÄ x ‚àà s, 0 ‚â§ x) ‚Üí s.IsPWO ‚Üí (‚Üë(AddSubmonoid.closure s)).IsPWO

=======================

Nat.multinomial_insert :

‚àÄ {Œ± : Type u_1} {s : Finset Œ±} {a : Œ±} [inst : DecidableEq Œ±],
  a ‚àâ s ‚Üí ‚àÄ (f : Œ± ‚Üí ‚Ñï), Nat.multinomial (insert a s) f = (f a + ‚àë i ‚àà s, f i).choose (f a) * Nat.multinomial s f

=======================

Set.sep_eq_of_subset :

‚àÄ {Œ± : Type u} {s t : Set Œ±}, s ‚äÜ t ‚Üí {x | x ‚àà t ‚àß x ‚àà s} = s

=======================

Int.floor_zero :

‚àÄ {R : Type u_2} [inst : Ring R] [inst_1 : LinearOrder R] [inst_2 : FloorRing R] [IsStrictOrderedRing R], ‚åä0‚åã = 0

=======================

Nat.factorization_def :

‚àÄ (n : ‚Ñï) {p : ‚Ñï}, Nat.Prime p ‚Üí n.factorization p = padicValNat p n

=======================

Set.OrdConnected.dual :

‚àÄ {Œ± : Type u_1} [inst : Preorder Œ±] {s : Set Œ±}, s.OrdConnected ‚Üí (‚áëOrderDual.ofDual ‚Åª¬π' s).OrdConnected

=======================

Nat.lt_of_lt_pred :

‚àÄ {m n : ‚Ñï}, m < n - 1 ‚Üí m < n

=======================

Real.tendsto_logb_nat_add_one_sub_logb :

‚àÄ {b : ‚Ñù}, Filter.Tendsto (fun k ‚Ü¶ Real.logb b (‚Üëk + 1) - Real.logb b ‚Üëk) Filter.atTop (nhds 0)

=======================

Finset.not_subset :

‚àÄ {Œ± : Type u_1} {s t : Finset Œ±}, ¬¨s ‚äÜ t ‚Üî ‚àÉ x ‚àà s, x ‚àâ t

=======================

Real.Lp_add_le_tsum_of_nonneg :

‚àÄ {Œπ : Type u} {f g : Œπ ‚Üí ‚Ñù} {p : ‚Ñù},
  1 ‚â§ p ‚Üí
    (‚àÄ (i : Œπ), 0 ‚â§ f i) ‚Üí
      (‚àÄ (i : Œπ), 0 ‚â§ g i) ‚Üí
        (Summable fun i ‚Ü¶ f i ^ p) ‚Üí
          (Summable fun i ‚Ü¶ g i ^ p) ‚Üí
            (Summable fun i ‚Ü¶ (f i + g i) ^ p) ‚àß
              (‚àë' (i : Œπ), (f i + g i) ^ p) ^ (1 / p) ‚â§
                (‚àë' (i : Œπ), f i ^ p) ^ (1 / p) + (‚àë' (i : Œπ), g i ^ p) ^ (1 / p)

=======================

Finset.fold_max_le :

‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {f : Œ± ‚Üí Œ≤} {b : Œ≤} {s : Finset Œ±} [inst : LinearOrder Œ≤] (c : Œ≤),
  Finset.fold max b f s ‚â§ c ‚Üî b ‚â§ c ‚àß ‚àÄ x ‚àà s, f x ‚â§ c

=======================

Set.biUnion_self :

‚àÄ {Œ± : Type u_1} (s : Set Œ±), ‚ãÉ x ‚àà s, s = s

=======================

Nat.Icc_insert_succ_right :

‚àÄ {a b : ‚Ñï}, a ‚â§ b + 1 ‚Üí insert (b + 1) (Finset.Icc a b) = Finset.Icc a (b + 1)

=======================

Int.add_lt_add_of_lt_of_le :

‚àÄ {a b c d : ‚Ñ§}, a < b ‚Üí c ‚â§ d ‚Üí a + c < b + d

=======================

Finset.coeEmb.eq_1 :

‚àÄ {Œ± : Type u_1}, Finset.coeEmb = { toFun := Finset.toSet, inj' := ‚ãØ, map_rel_iff' := ‚ãØ }

=======================

Set.preimage_neg_Ico :

‚àÄ {Œ± : Type u_1} [inst : AddCommGroup Œ±] [inst_1 : PartialOrder Œ±] [IsOrderedAddMonoid Œ±] (a b : Œ±),
  -Set.Ico a b = Set.Ioc (-b) (-a)

=======================

Nat.totient_even :

‚àÄ {n : ‚Ñï}, 2 < n ‚Üí Even n.totient

=======================

Finset.supIndep_empty :

‚àÄ {Œ± : Type u_1} {Œπ : Type u_3} [inst : Lattice Œ±] [inst_1 : OrderBot Œ±] (f : Œπ ‚Üí Œ±), ‚àÖ.SupIndep f

=======================

Finset.centerMass_filter_ne_zero :

‚àÄ {R : Type u_1} {E : Type u_3} {Œπ : Type u_5} [inst : Field R] [inst_1 : AddCommGroup E] [inst_2 : _root_.Module R E]
  {t : Finset Œπ} {w : Œπ ‚Üí R} (z : Œπ ‚Üí E) [inst_3 : (i : Œπ) ‚Üí Decidable (w i ‚â† 0)],
  {i ‚àà t | w i ‚â† 0}.centerMass w z = t.centerMass w z

=======================

Set.up_image :

‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} [inst : MulOneClass Œ±] [inst_1 : MulOneClass Œ≤] (f : Œ± ‚Üí* Œ≤) (s : Set Œ±),
  Set.up (‚áëf '' s) = (SetSemiring.imageHom f) (Set.up s)

=======================

Int.Ioc_filter_modEq_card :

‚àÄ (a b : ‚Ñ§) {r : ‚Ñ§},
  0 < r ‚Üí ‚àÄ (v : ‚Ñ§), ‚Üë{x ‚àà Finset.Ioc a b | x ‚â° v [ZMOD r]}.card = max (‚åä(‚Üëb - ‚Üëv) / ‚Üër‚åã - ‚åä(‚Üëa - ‚Üëv) / ‚Üër‚åã) 0

=======================

Set.OrdConnected.inter' :

‚àÄ {Œ± : Type u_1} [inst : Preorder Œ±] {s t : Set Œ±} [s.OrdConnected] [t.OrdConnected], (s ‚à© t).OrdConnected

=======================

Int.neg_eq_neg :

‚àÄ {a b : ‚Ñ§}, -a = -b ‚Üí a = b

=======================

Nat.instAssociativeHAdd :

Std.Associative fun x1 x2 ‚Ü¶ x1 + x2

=======================

Set.nonempty_Ici :

‚àÄ {Œ± : Type u_1} [inst : Preorder Œ±] {a : Œ±}, (Set.Ici a).Nonempty

=======================

Real.neg_inv_le_log :

‚àÄ {x : ‚Ñù}, 0 ‚â§ x ‚Üí -x‚Åª¬π ‚â§ Real.log x

=======================

Int.units_inv_eq_self :

‚àÄ (u : ‚Ñ§À£), u‚Åª¬π = u

=======================

Finset.set_biInter_option_toFinset :

‚àÄ {Œ± : Type u_2} {Œ≤ : Type u_3} (o : Option Œ±) (f : Œ± ‚Üí Set Œ≤), ‚ãÇ x ‚àà o.toFinset, f x = ‚ãÇ x ‚àà o, f x

=======================

Finset.card_nbij :

‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {s : Finset Œ±} {t : Finset Œ≤} (i : Œ± ‚Üí Œ≤),
  Set.MapsTo i ‚Üës ‚Üët ‚Üí Set.InjOn i ‚Üës ‚Üí Set.SurjOn i ‚Üës ‚Üët ‚Üí s.card = t.card

=======================

Set.Intersecting.mono :

‚àÄ {Œ± : Type u_1} [inst : SemilatticeInf Œ±] [inst_1 : OrderBot Œ±] {s t : Set Œ±}, t ‚äÜ s ‚Üí s.Intersecting ‚Üí t.Intersecting

=======================

Set.one_le_mulIndicator :

‚àÄ {Œ± : Type u_2} {M : Type u_3} [inst : Preorder M] [inst_1 : One M] {s : Set Œ±} {f : Œ± ‚Üí M},
  (‚àÄ a ‚àà s, 1 ‚â§ f a) ‚Üí ‚àÄ (a : Œ±), 1 ‚â§ s.mulIndicator f a

=======================

Nat.nth_apply_eq_orderIsoOfNat :

‚àÄ {p : ‚Ñï ‚Üí Prop} (hf : (setOf p).Infinite) (n : ‚Ñï), Nat.nth p n = ‚Üë((Nat.Subtype.orderIsoOfNat (setOf p)) n)

=======================

Finset.ofDual_sup' :

‚àÄ {Œ± : Type u_2} {Œπ : Type u_5} [inst : SemilatticeInf Œ±] {s : Finset Œπ} (hs : s.Nonempty) (f : Œπ ‚Üí Œ±·µí·µà),
  OrderDual.ofDual (s.sup' hs f) = s.inf' hs (‚áëOrderDual.ofDual ‚àò f)

=======================

Finset.Colex.singleton_lt_singleton :

‚àÄ {Œ± : Type u_1} [inst : PartialOrder Œ±] {a b : Œ±}, { ofColex := {a} } < { ofColex := {b} } ‚Üî a < b

=======================

Set.nontrivial_iff_ne_singleton :

‚àÄ {Œ± : Type u} {a : Œ±} {s : Set Œ±}, a ‚àà s ‚Üí (s.Nontrivial ‚Üî s ‚â† {a})

=======================

Finset.mem_erase_of_ne_of_mem :

‚àÄ {Œ± : Type u_1} [inst : DecidableEq Œ±] {s : Finset Œ±} {a b : Œ±}, a ‚â† b ‚Üí a ‚àà s ‚Üí a ‚àà s.erase b

=======================

Nat.coprime_primes :

‚àÄ {p q : ‚Ñï}, Nat.Prime p ‚Üí Nat.Prime q ‚Üí (p.Coprime q ‚Üî p ‚â† q)

=======================

Int.add_neg_mul_emod_self_left :

‚àÄ (a b c : ‚Ñ§), (a + -(b * c)) % b = a % b

=======================

Real.isSquare_iff :

‚àÄ {x : ‚Ñù}, IsSquare x ‚Üî 0 ‚â§ x

=======================

Nat.prime_of_mem_primeFactorsList :

‚àÄ {n p : ‚Ñï}, p ‚àà n.primeFactorsList ‚Üí Nat.Prime p

=======================

Int.coe_lcm :

‚àÄ (i j : ‚Ñ§), ‚Üë(i.lcm j) = lcm i j

=======================

Nat.left_ne_zero_of_mem_divisorsAntidiagonal :

‚àÄ {n : ‚Ñï} {p : ‚Ñï √ó ‚Ñï}, p ‚àà n.divisorsAntidiagonal ‚Üí p.1 ‚â† 0

=======================

Set.Ici_top :

‚àÄ {Œ± : Type u_1} [inst : PartialOrder Œ±] [inst_1 : OrderTop Œ±], Set.Ici ‚ä§ = {‚ä§}

=======================

Set.Icc_eq_empty_of_lt :

‚àÄ {Œ± : Type u_1} [inst : Preorder Œ±] {a b : Œ±}, b < a ‚Üí Set.Icc a b = ‚àÖ

=======================

Set.encard_insert_le :

‚àÄ {Œ± : Type u_1} (s : Set Œ±) (x : Œ±), (insert x s).encard ‚â§ s.encard + 1

=======================

Real.posLog.eq_1 :

‚àÄ (r : ‚Ñù), r.posLog = max 0 (Real.log r)

=======================

Set.InjOn.mono :

‚àÄ {Œ± : Type u_1} {Œ≤ : Type u_2} {s‚ÇÅ s‚ÇÇ : Set Œ±} {f : Œ± ‚Üí Œ≤}, s‚ÇÅ ‚äÜ s‚ÇÇ ‚Üí Set.InjOn f s‚ÇÇ ‚Üí Set.InjOn f s‚ÇÅ

=======================

Finset.Colex.le_def :

‚àÄ {Œ± : Type u_1} [inst : PartialOrder Œ±] {s t : Finset.Colex Œ±},
  s ‚â§ t ‚Üî ‚àÄ ‚¶Éa : Œ±‚¶Ñ, a ‚àà s.ofColex ‚Üí a ‚àâ t.ofColex ‚Üí ‚àÉ b ‚àà t.ofColex, b ‚àâ s.ofColex ‚àß a ‚â§ b

=======================

Set.Definable.mono :

‚àÄ {M : Type w} {A : Set M} {L : FirstOrder.Language} [inst : L.Structure M] {Œ± : Type u‚ÇÅ} {B : Set M} {s : Set (Œ± ‚Üí M)},
  A.Definable L s ‚Üí A ‚äÜ B ‚Üí B.Definable L s

=======================

Nat.Partition.count_ofSums_of_ne_zero :

‚àÄ {n : ‚Ñï} {l : Multiset ‚Ñï} (hl : l.sum = n) {i : ‚Ñï},
  i ‚â† 0 ‚Üí Multiset.count i (Nat.Partition.ofSums n l hl).parts = Multiset.count i l

=======================

Nat.mem_primeFactorsList_mul_of_coprime :

‚àÄ {a b : ‚Ñï}, a.Coprime b ‚Üí ‚àÄ (p : ‚Ñï), p ‚àà (a * b).primeFactorsList ‚Üî p ‚àà a.primeFactorsList ‚à™ b.primeFactorsList

=======================

Real.inv_logb_div_base :

‚àÄ {a b : ‚Ñù}, a ‚â† 0 ‚Üí b ‚â† 0 ‚Üí ‚àÄ (c : ‚Ñù), (Real.logb (a / b) c)‚Åª¬π = (Real.logb a c)‚Åª¬π - (Real.logb b c)‚Åª¬π

=======================

Set.isAtom_iff :

‚àÄ {Œ± : Type u_2} {s : Set Œ±}, IsAtom s ‚Üî ‚àÉ x, s = {x}

=======================

Finset.coe_nonempty :

‚àÄ {Œ± : Type u_1} {s : Finset Œ±}, (‚Üës).Nonempty ‚Üî s.Nonempty

=======================

Finset.prod_Ioo_mul_right :

‚àÄ {Œ± : Type u_1} {M : Type u_2} [inst : CommMonoid M] {f : Œ± ‚Üí M} {a b : Œ±} [inst_1 : PartialOrder Œ±]
  [inst_2 : LocallyFiniteOrder Œ±], a < b ‚Üí (‚àè x ‚àà Finset.Ioo a b, f x) * f b = ‚àè x ‚àà Finset.Ioc a b, f x

=======================

Nat.factorization_choose_eq_zero_of_lt :

‚àÄ {p n k : ‚Ñï}, n < p ‚Üí (n.choose k).factorization p = 0

=======================

Set.VAddAntidiagonal.eq_of_fst_le_fst_of_snd_le_snd :

‚àÄ {G : Type u_1} {P : Type u_2} {s : Set G} {t : Set P} {a : P} [inst : PartialOrder G] [inst_1 : PartialOrder P]
  [inst_2 : VAdd G P] [IsOrderedCancelVAdd G P] {x y : ‚Üë(s.vaddAntidiagonal t a)},
  (‚Üëx).1 ‚â§ (‚Üëy).1 ‚Üí (‚Üëx).2 ‚â§ (‚Üëy).2 ‚Üí x = y

=======================

Finset.isPWO_sup :

‚àÄ {Œπ : Type u_1} {Œ± : Type u_2} [inst : Preorder Œ±] (s : Finset Œπ) {f : Œπ ‚Üí Set Œ±},
  (s.sup f).IsPWO ‚Üî ‚àÄ i ‚àà s, (f i).IsPWO

=======================

Int.dvd_div_iff_mul_dvd :

‚àÄ {a b c : ‚Ñ§}, c ‚à£ b ‚Üí (a ‚à£ b / c ‚Üî c * a ‚à£ b)

=======================

Finset.prod_Ico_add :

‚àÄ {Œ± : Type u_1} {M : Type u_3} [inst : CommMonoid M] [inst_1 : AddCommMonoid Œ±] [inst_2 : PartialOrder Œ±]
  [IsOrderedCancelAddMonoid Œ±] [ExistsAddOfLE Œ±] [inst_5 : LocallyFiniteOrder Œ±] (f : Œ± ‚Üí M) (a b c : Œ±),
  ‚àè x ‚àà Finset.Ico a b, f (c + x) = ‚àè x ‚àà Finset.Ico (a + c) (b + c), f x

=======================

Real.cosh_add :

‚àÄ (x y : ‚Ñù), Real.cosh (x + y) = Real.cosh x * Real.cosh y + Real.sinh x * Real.sinh y

=======================

Set.mem_ordConnectedComponent :

‚àÄ {Œ± : Type u_1} [inst : LinearOrder Œ±] {s : Set Œ±} {x y : Œ±}, y ‚àà s.ordConnectedComponent x ‚Üî Set.uIcc x y ‚äÜ s

=======================

Nat.lt_of_shiftLeft_lt :

‚àÄ {a b c : ‚Ñï}, a <<< b < c ‚Üí a < c

=======================

Set.mulIndicator_le_mulIndicator_apply_of_subset :

‚àÄ {Œ± : Type u_2} {M : Type u_3} [inst : Preorder M] [inst_1 : One M] {s t : Set Œ±} {f : Œ± ‚Üí M} {a : Œ±},
  s ‚äÜ t ‚Üí 1 ‚â§ f a ‚Üí s.mulIndicator f a ‚â§ t.mulIndicator f a

=======================

Finset.Nat.sum_antidiagonal_succ :

‚àÄ {N : Type u_2} [inst : AddCommMonoid N] {n : ‚Ñï} {f : ‚Ñï √ó ‚Ñï ‚Üí N},
  ‚àë p ‚àà Finset.antidiagonal (n + 1), f p = f (0, n + 1) + ‚àë p ‚àà Finset.antidiagonal n, f (p.1 + 1, p.2)

=======================

Real.logb_rpow :

‚àÄ {b x : ‚Ñù}, 0 < b ‚Üí b ‚â† 1 ‚Üí Real.logb b (b ^ x) = x

=======================

